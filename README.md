# A3

## Расположение файлов

- `RandomStreamGen.hpp` — генератор потока данных S  
- `HashFuncGen.hpp` — генератор хеш-функции
- `HyperLogLog.hpp` — реализация HyperLogLog 
- `ExactF0.hpp` — точный подсчёт `F0`  
- `MultiHLL.hpp`, `median_helper.hpp` — улучшение (K HyperLogLog + медиана)  
- `stage2_run.cpp`, `stage4_run.cpp` — эксперименты  
- `stage2_results.csv`, `stage4_results.csv` — результаты  
- `compare_stage2_stage4.py` — построение сравнительных графиков

## Графики

- `этап2_истина_и_оценка.png` - график 1 этапа 2
- `этап2_среднее_плюс_минус_сигма.png` - график 2 этапа 2
- `этап4_истина_и_оценка.png` - график 1 этапа 4
- `этап4_среднее_плюс_минус_сигма.png` - график 2 этапа 4
дополнительно:
- `сравнение_зон_сигма.png` - сравнение зон ±σ 2 и 4 этапов
- `сравнение_средних_оценок.png` - сравнение средних оценок 2 и 4 этапов
- `сравнение_относительной_ошибки.png` - сравнение относительной ошибки 2 и 4 этапов
- `сравнение_отношения_сигма.png` - сравнение отношения σ 2 и 4 этапов

## Этап 2

### Краткое обоснование выбора B

m = 2^B регистров
Теоретическая относительная ошибка из условия этапа 3 будет порядка ≈ 1.04 / sqrt(m)
Если выбрать B = 10 → m = 1024
Тогда 1.04 / sqrt(1024) = 1.04 / 32 ≈ 3.25%
Если хранить регистры uint8_t, то при m = 1024 это будет 1024 байта

### Точный подсчет \[F0^t\]

Файл ExactF0.hpp - считаем как unordered_set на префиксе потока

### Выборочные статистики для всех сгенерированных потоков

`t` - моменты времени (10%, 20%, ..., 100%)
Для каждого `t` считается:
- `F0^t` (точно),
- `N_t` (HyperLongLong),
затем по прогонам:
- `E(N_t)` — среднее,
- `σ(N_t)` — стандартное отклонение.

Далее для графиков создается csv файл, который содержит следующие колонки:

percent, trueF0, meanNt, stdevNt, meanMinusSigma, meanPlusSigma

percent — X (момент времени t как % обработанного потока)
trueF0 — линия истины `F0^t` 
meanNt — линия `E(N_t)`
stdevNt — `σ`
meanMinusSigma, meanPlusSigma — закрашенная область

## Этап 3

При `B=10` ожидаемый порядок относительной ошибки:
- нижняя граница: **0.0325** (≈ 3.25%)
- верхняя граница: **0.0406** (≈ 4.06%)

По результатам:
- максимальная абсолютная относительная ошибка (по t): **0.590%**
- средняя абсолютная относительная ошибка: **0.332%**

#### Точность

Линия `E(N_t)` идет рядом с `F0^t` 

#### Стабильность оценки (дисперсия)

`σ(N_t)` растет по мере роста `F0^t` (потому что абсолютные значения больше)

#### Эффективность

Память растет линейно по m. Больше ошибок -> должно быть меньше ошибок, чтобы соблюдать баланс в вероятностных структурах. В разработанном алгоритме чем больше регистров m = `2^B`, тем меньше относительная ошибка.

## 4.

### Улучшение

Нужно снижать вероятность ошибок или коллизий через независимые хеши (из занятий).
Создаём K независимых HyperLongLong и объединяем их оценки медианой:
\[
\hat{N}_t = \mathrm{median}\left(N_t^{(1)},\dots,N_t^{(K)}\right)
\]
Медиана устойчива к выбросам: один плохой хеш на конкретном потоке не сможет сильно сместить итог, поэтому дисперсия уменьшается.

В экспериментах: K = 9.

### Изменения

- Время обновления растёт примерно в K раз
- Память растёт линейно. Для `B=10` и `K=9`: около 9·1024 = 9216 байт под регистры.

Средняя ошибка не ухудшается, разброс уменьшается
Абсолютная относительная ошибка:
- Этап 2: max 0.590%, mean 0.332%
- Этап 4: max 0.374%, mean 0.102%
σ уменьшилась примерно в 2,5 раза

